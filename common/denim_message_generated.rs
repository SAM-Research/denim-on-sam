// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod denim_message_flatbuffer {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FLAG: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FLAG: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FLAG: [Flag; 4] = [
  Flag::DEFAULT,
  Flag::IS_FINAL,
  Flag::NOT_FINAL,
  Flag::DUMMY_PADDING,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Flag(pub i8);
#[allow(non_upper_case_globals)]
impl Flag {
  pub const DEFAULT: Self = Self(0);
  pub const IS_FINAL: Self = Self(1);
  pub const NOT_FINAL: Self = Self(2);
  pub const DUMMY_PADDING: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::IS_FINAL,
    Self::NOT_FINAL,
    Self::DUMMY_PADDING,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DEFAULT => Some("DEFAULT"),
      Self::IS_FINAL => Some("IS_FINAL"),
      Self::NOT_FINAL => Some("NOT_FINAL"),
      Self::DUMMY_PADDING => Some("DUMMY_PADDING"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Flag {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Flag {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Flag {
    type Output = Flag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Flag {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Flag {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Flag {}
pub enum DenimChunkOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DenimChunk<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DenimChunk<'a> {
  type Inner = DenimChunk<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DenimChunk<'a> {
  pub const VT_CHUNK: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SEQUENCE_NUMBER: flatbuffers::VOffsetT = 8;
  pub const VT_FLAG: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DenimChunk { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DenimChunkArgs<'args>
  ) -> flatbuffers::WIPOffset<DenimChunk<'bldr>> {
    let mut builder = DenimChunkBuilder::new(_fbb);
    builder.add_sequence_number(args.sequence_number);
    builder.add_message_id(args.message_id);
    if let Some(x) = args.chunk { builder.add_chunk(x); }
    builder.add_flag(args.flag);
    builder.finish()
  }

  pub fn unpack(&self) -> DenimChunkT {
    let chunk = {
      let x = self.chunk();
      x.into_iter().collect()
    };
    let message_id = self.message_id();
    let sequence_number = self.sequence_number();
    let flag = self.flag();
    DenimChunkT {
      chunk,
      message_id,
      sequence_number,
      flag,
    }
  }

  #[inline]
  pub fn chunk(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DenimChunk::VT_CHUNK, None).unwrap()}
  }
  #[inline]
  pub fn message_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DenimChunk::VT_MESSAGE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sequence_number(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(DenimChunk::VT_SEQUENCE_NUMBER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flag(&self) -> Flag {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Flag>(DenimChunk::VT_FLAG, Some(Flag::DEFAULT)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DenimChunk<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("chunk", Self::VT_CHUNK, true)?
     .visit_field::<u32>("message_id", Self::VT_MESSAGE_ID, false)?
     .visit_field::<u32>("sequence_number", Self::VT_SEQUENCE_NUMBER, false)?
     .visit_field::<Flag>("flag", Self::VT_FLAG, false)?
     .finish();
    Ok(())
  }
}
pub struct DenimChunkArgs<'a> {
    pub chunk: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub message_id: u32,
    pub sequence_number: u32,
    pub flag: Flag,
}
impl<'a> Default for DenimChunkArgs<'a> {
  #[inline]
  fn default() -> Self {
    DenimChunkArgs {
      chunk: None, // required field
      message_id: 0,
      sequence_number: 0,
      flag: Flag::DEFAULT,
    }
  }
}

pub struct DenimChunkBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DenimChunkBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_chunk(&mut self, chunk: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DenimChunk::VT_CHUNK, chunk);
  }
  #[inline]
  pub fn add_message_id(&mut self, message_id: u32) {
    self.fbb_.push_slot::<u32>(DenimChunk::VT_MESSAGE_ID, message_id, 0);
  }
  #[inline]
  pub fn add_sequence_number(&mut self, sequence_number: u32) {
    self.fbb_.push_slot::<u32>(DenimChunk::VT_SEQUENCE_NUMBER, sequence_number, 0);
  }
  #[inline]
  pub fn add_flag(&mut self, flag: Flag) {
    self.fbb_.push_slot::<Flag>(DenimChunk::VT_FLAG, flag, Flag::DEFAULT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DenimChunkBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DenimChunkBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DenimChunk<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DenimChunk::VT_CHUNK,"chunk");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DenimChunk<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DenimChunk");
      ds.field("chunk", &self.chunk());
      ds.field("message_id", &self.message_id());
      ds.field("sequence_number", &self.sequence_number());
      ds.field("flag", &self.flag());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DenimChunkT {
  pub chunk: Vec<u8>,
  pub message_id: u32,
  pub sequence_number: u32,
  pub flag: Flag,
}
impl Default for DenimChunkT {
  fn default() -> Self {
    Self {
      chunk: Default::default(),
      message_id: 0,
      sequence_number: 0,
      flag: Flag::DEFAULT,
    }
  }
}
impl DenimChunkT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DenimChunk<'b>> {
    let chunk = Some({
      let x = &self.chunk;
      _fbb.create_vector(x)
    });
    let message_id = self.message_id;
    let sequence_number = self.sequence_number;
    let flag = self.flag;
    DenimChunk::create(_fbb, &DenimChunkArgs{
      chunk,
      message_id,
      sequence_number,
      flag,
    })
  }
}
pub enum DenimMessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DenimMessage<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DenimMessage<'a> {
  type Inner = DenimMessage<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DenimMessage<'a> {
  pub const VT_REG_MESSAGE: flatbuffers::VOffsetT = 4;
  pub const VT_DENIABLE_PAYLOAD: flatbuffers::VOffsetT = 6;
  pub const VT_GARBAGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DenimMessage { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DenimMessageArgs<'args>
  ) -> flatbuffers::WIPOffset<DenimMessage<'bldr>> {
    let mut builder = DenimMessageBuilder::new(_fbb);
    if let Some(x) = args.garbage { builder.add_garbage(x); }
    if let Some(x) = args.deniable_payload { builder.add_deniable_payload(x); }
    if let Some(x) = args.reg_message { builder.add_reg_message(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> DenimMessageT {
    let reg_message = {
      let x = self.reg_message();
      x.into_iter().collect()
    };
    let deniable_payload = {
      let x = self.deniable_payload();
      x.iter().map(|t| t.unpack()).collect()
    };
    let garbage = self.garbage().map(|x| {
      x.into_iter().collect()
    });
    DenimMessageT {
      reg_message,
      deniable_payload,
      garbage,
    }
  }

  #[inline]
  pub fn reg_message(&self) -> flatbuffers::Vector<'a, u8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DenimMessage::VT_REG_MESSAGE, None).unwrap()}
  }
  #[inline]
  pub fn deniable_payload(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DenimChunk<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DenimChunk>>>>(DenimMessage::VT_DENIABLE_PAYLOAD, None).unwrap()}
  }
  #[inline]
  pub fn garbage(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DenimMessage::VT_GARBAGE, None)}
  }
}

impl flatbuffers::Verifiable for DenimMessage<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("reg_message", Self::VT_REG_MESSAGE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DenimChunk>>>>("deniable_payload", Self::VT_DENIABLE_PAYLOAD, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("garbage", Self::VT_GARBAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct DenimMessageArgs<'a> {
    pub reg_message: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub deniable_payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DenimChunk<'a>>>>>,
    pub garbage: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for DenimMessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    DenimMessageArgs {
      reg_message: None, // required field
      deniable_payload: None, // required field
      garbage: None,
    }
  }
}

pub struct DenimMessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DenimMessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_reg_message(&mut self, reg_message: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DenimMessage::VT_REG_MESSAGE, reg_message);
  }
  #[inline]
  pub fn add_deniable_payload(&mut self, deniable_payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DenimChunk<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DenimMessage::VT_DENIABLE_PAYLOAD, deniable_payload);
  }
  #[inline]
  pub fn add_garbage(&mut self, garbage: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DenimMessage::VT_GARBAGE, garbage);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DenimMessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DenimMessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DenimMessage<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DenimMessage::VT_REG_MESSAGE,"reg_message");
    self.fbb_.required(o, DenimMessage::VT_DENIABLE_PAYLOAD,"deniable_payload");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DenimMessage<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DenimMessage");
      ds.field("reg_message", &self.reg_message());
      ds.field("deniable_payload", &self.deniable_payload());
      ds.field("garbage", &self.garbage());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DenimMessageT {
  pub reg_message: Vec<u8>,
  pub deniable_payload: Vec<DenimChunkT>,
  pub garbage: Option<Vec<u8>>,
}
impl Default for DenimMessageT {
  fn default() -> Self {
    Self {
      reg_message: Default::default(),
      deniable_payload: Default::default(),
      garbage: None,
    }
  }
}
impl DenimMessageT {
  pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>
  ) -> flatbuffers::WIPOffset<DenimMessage<'b>> {
    let reg_message = Some({
      let x = &self.reg_message;
      _fbb.create_vector(x)
    });
    let deniable_payload = Some({
      let x = &self.deniable_payload;
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let garbage = self.garbage.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    DenimMessage::create(_fbb, &DenimMessageArgs{
      reg_message,
      deniable_payload,
      garbage,
    })
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `DenimChunk`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_denim_chunk_unchecked`.
pub fn root_as_denim_chunk(buf: &[u8]) -> Result<DenimChunk, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<DenimChunk>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `DenimChunk` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_denim_chunk_unchecked`.
pub fn size_prefixed_root_as_denim_chunk(buf: &[u8]) -> Result<DenimChunk, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<DenimChunk>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `DenimChunk` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_denim_chunk_unchecked`.
pub fn root_as_denim_chunk_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DenimChunk<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<DenimChunk<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `DenimChunk` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_denim_chunk_unchecked`.
pub fn size_prefixed_root_as_denim_chunk_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<DenimChunk<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<DenimChunk<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a DenimChunk and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `DenimChunk`.
pub unsafe fn root_as_denim_chunk_unchecked(buf: &[u8]) -> DenimChunk {
  flatbuffers::root_unchecked::<DenimChunk>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed DenimChunk and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `DenimChunk`.
pub unsafe fn size_prefixed_root_as_denim_chunk_unchecked(buf: &[u8]) -> DenimChunk {
  flatbuffers::size_prefixed_root_unchecked::<DenimChunk>(buf)
}
#[inline]
pub fn finish_denim_chunk_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<DenimChunk<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_denim_chunk_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<DenimChunk<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod denim_message_flatbuffer

